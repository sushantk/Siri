Principles
   * Module oriented
   * Simple to get started
   * Reduce boiler plate code and markup
   * Markup and code equally accessible
   * Super performant!!

Progressive complexity

// traditional single source and renderer
"foo" : {
    "model" : {
        "url" : "..."
    }

    "view" : {
        "template" : ".."
    }
}

// traditional MVC
"foo" : {

    /* Controller returns the source id and overriden parameters.
       On source completion, it may next source id or finish.
       It also returns the renderer id after it is done with sources. */
    "controller" : {
    }

    "model" : [
       {
           "@id" : "default",
           ....
       },
       {
           "@id" : "update",
           ....
       },
    ]

    "view" : [
      {
           "@id" : "default"
           "template" : ".."
      },
      {
           "@id" : "config"
           "template" : ".."
      }
    ]
}

// controller class
interface Controller {
    // Config tree would contain the id and the params
    Callback getModel(Context a_context, ConfigTree a_module, ConfigTree a_model);

    DataObject getFinalResponse(Map<String, DataObject> a_data);
}

//  this model  allows a data object construction from the raw data.
{
    "@id" : ""
    "@class" : "ModelDataObject",

    "dataObject" : {
        "@class" : "WeatherDataObject" // constructor gets the raw data
    }

    // sub model
    model: {
    ...
    }
}

/*  This model extends from the ModelDataObject.
    it allows to run one or more sub models in parallel.
    it also allows model to provide overriden parameters.
    if aggregator is not specified, all the sub models are run
    on completion, it allows model to chain more sources or construct the final data. */
{
    "@id" : "user_weather"
    "@class" : "ModelAggregate",

    "aggregator" : {
        "@class" : "ModelUserWeather"
    }

    // sub models
    model: [
        {
            "@id" : "user_setting",
            ...
        },
        {
            "@id" : "weather",
            ...
        },
    ]
}



Streaming

Open connection
Client side framework

Callback
   * callbacks should return object tree
   * callback joiner

TaskManager
   * Interleaves sync and async tasks
   * If all sync tasks are over, then waits for an async task to get ready
   * Makes sure tasks execute in a single thread

SourceWebService
   * deduping
   * populate metadata in DO

SourceCache
   * "use" for subsource
      * How can controller override subsource's url?
   * collapse when refreshing
   
Logging

Event

ObjectTree
   * "use" - two phase configure
  
Caching
   * Memory caching for repo related
   * JCS for data

Testing
   * Component testing with mocked inputs.
   * Logs are critical, think of users trying to debug rather than you. 

